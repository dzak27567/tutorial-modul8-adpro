# Reflection Modul 8

## What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?
Perbedaan utama dari ketiga metode RPC tersebut terletak pada arah dan jumlah komunikasi dalam satu koneksi. Unary RPC memungkinkan client mengirim satu request dan menerima satu response, cocok untuk operasi sederhana seperti autentikasi atau pencarian data. Server streaming memungkinkan client mengirim satu request dan menerima banyak response secara bertahap dari server, yang sesuai untuk kasus seperti update cuaca atau harga saham. Sementara itu, bi-directional streaming memungkinkan komunikasi dua arah secara bersamaan, di mana client dan server bisa terus bertukar pesan selama koneksi terbuka. Ini sangat ideal untuk aplikasi real-time seperti chat atau streaming data.

## What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
Dalam membangun layanan gRPC di Rust, keamanan merupakan aspek penting yang meliputi autentikasi untuk memverifikasi identitas client, otorisasi untuk memastikan client memiliki hak akses terhadap resource tertentu, serta enkripsi data untuk menjaga keamanan komunikasi melalui TLS. Rust memberikan kontrol yang ketat terhadap memori dan concurrency, tetapi pengembang tetap harus teliti dalam mengelola sertifikat, token akses, dan sistem validasi agar tidak muncul celah keamanan.

## What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
Penggunaan bi-directional streaming di Rust, terutama dalam aplikasi seperti chat, dapat menghadirkan tantangan seperti race condition, di mana dua pesan dari client diterima hampir bersamaan dan menyebabkan konflik urutan pemrosesan. Selain itu, sinkronisasi data menjadi penting untuk memastikan tidak terjadi inkonsistensi, dan pengelolaan koneksi serta resource harus dilakukan dengan hati-hati agar tidak menimbulkan memory leak atau deadlock. Rust membantu melalui fitur seperti tokio, mutex, dan ownership system, tetapi desain program harus tetap hati-hati.

## What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
ReceiverStream memberikan kemudahan dalam membungkus channel menjadi stream tanpa perlu mengatur streaming secara manual, sehingga cocok untuk pola async modern di Rust. Keuntungannya adalah menyederhanakan proses streaming dan menangani sinkronisasi dengan cara yang lebih aman. Namun, kerugiannya adalah kompleksitas tambahan dari pemrograman asynchronous yang bisa membingungkan, terutama bagi pengembang yang belum terbiasa dengan model ini.

## In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?
Agar kode Rust gRPC dapat terstruktur dengan baik, sebaiknya layanan dibagi ke dalam modul atau folder berdasarkan jenis RPC-nya (seperti unary, server streaming, dan bi-directional). Interface dapat didefinisikan di file .proto, dan implementasinya dipisah ke dalam struct dan trait tersendiri. Dengan pemisahan yang modular seperti ini, kode akan lebih mudah dipelihara, diuji, dan dikembangkan seiring bertambahnya fitur atau perubahan arsitektur.

## In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?
Untuk menangani logic pembayaran yang lebih kompleks, bisa diterapkan pemrosesan asynchronous atau multi-threaded agar server mampu menangani beberapa permintaan client secara paralel tanpa bottleneck. Selain itu, dibutuhkan sistem validasi transaksi yang kuat, error handling yang baik, dan mungkin integrasi dengan sistem antrian atau database eksternal agar transaksi bisa diproses secara akurat dan efisien.

## #What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
Penggunaan gRPC membawa dampak besar dalam mendesain sistem terdistribusi, terutama pada aspek interoperabilitas. Dengan menggunakan Protocol Buffers sebagai format data, layanan dari berbagai bahasa pemrograman dapat saling berkomunikasi dengan efisien tanpa perlu membuat format data sendiri. gRPC juga mendukung koneksi yang efisien melalui HTTP/2, yang memudahkan komunikasi antar microservices secara cepat dan ringan, sekaligus menjaga struktur data tetap konsisten.

## What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
HTTP/2 menawarkan koneksi persisten yang efisien dengan kemampuan multiplexing, yang memungkinkan banyak request dan response dalam satu koneksi tanpa blocking. Ini menjadikannya unggul dalam performa dibandingkan HTTP/1.1. Namun, implementasi HTTP/2 lebih kompleks dan sensitif terhadap kualitas jaringan karena seluruh komunikasi berlangsung dalam satu koneksi, yang bisa berdampak jika koneksi tidak stabil. Sementara itu, WebSocket menawarkan komunikasi dua arah seperti gRPC, tetapi tidak memiliki struktur dan validasi schema sebaik gRPC.

## How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
REST API menggunakan model request-response satu arah, di mana satu koneksi digunakan untuk satu pasangan permintaan dan jawaban, sehingga tidak efisien untuk komunikasi real-time karena membutuhkan pembukaan koneksi berulang. Sebaliknya, gRPC mendukung streaming dua arah, memungkinkan client dan server untuk terus bertukar data dalam satu koneksi secara terus-menerus. Ini sangat meningkatkan responsivitas dan mengurangi overhead pada aplikasi yang memerlukan komunikasi real-time.

## What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
Pendekatan schema-based seperti Protobuf di gRPC memberikan jaminan bahwa data sesuai dengan struktur yang sudah ditentukan, sehingga mengurangi kesalahan komunikasi antara client dan server. Sebaliknya, JSON bersifat fleksibel dan mudah dibaca, tetapi kurang ketat dalam struktur, sehingga berpotensi menimbulkan inkonsistensi jika tidak ada validasi manual. Dengan Protobuf, pengembang memiliki kontrol lebih baik terhadap validasi dan kompatibilitas antar sistem.